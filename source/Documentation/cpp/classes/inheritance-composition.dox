/** \page cppclassinheritcomp Inheritance & Composition
\tableofcontents

* **Inheritance creates an is-a relationship between classes, while composition creates a has-a relationship**. In other words, inheritance says, "I am this class with these other things," while composition says "This other class is one of my components."

\section cppclasscomp Composition
Composition is the term used for placing an object within a class. Say there are two classes, A and B. If you place an object of type A into the declaration of B, that is composition.
~~~
//A struct or a class will work here, both are user-defined datatypes.
class A {
private:
    int someValue;
    int someOtherValue;
public:
    A();
    A(int a, int b);
    int getSomeValue();
    int setSomeValue(int val);
    int getSomeOtherValue();
    int setSomeOtherValue(int val);
};

class B {
private:
    int x[10];
public:
    B();
    A member; //This is composition, placing one user-defined type within another.
};
~~~

You can access values in `A` from an object of `B` using the dot operator.

    B obj; //When the constructor for B is run, it invokes the constructor for A automatically.
    obj.member.setSomeValue(7);
    ...

\note Although this particular example is useless, there are still times where composition is necessary and useful.

\section cppclassinherit Inheritance
As was said above, inheritance creates an "is-a" relationship between classes.

Inheritance introduces the need for a new encapsulation level: `protected`. When a member is `private`, it is not accessible to a class that inherits it. Members that are labeled `protected` are accessible by derived classes, but not for general use. In other words, `protected` members are accessible to methods declared within the derived class, but not when the class is instantiated and used.

\subsection cppclassinherituml UML Diagrams
When you are developing an application that uses inheritance, you usually start with a **Universal Modeling Language (UML)** diagram. A UML diagram shows the relationship between classes within a program. In other words, it shows what classes are components (composition) or others and when classes inherit others.

The UML syntax is slightly different from that of C++ due to the fact that it is designed to describe multiple programming languages.

\note I used [Dia](http://dia-installer.de/index.html.en) to create the diagrams in this section. It is fairly self-explanatory, but the terminology is slightly different. Notably, member variables are called "attributes" and methods are called "operations".

Here is a sample class in UML.

\diafile ExampleClass.dia

###Explanation:
- Encapsulation levels are denoted with `+`, `-`, or `#`
    - `+`: public
    - `-`: private
    - `#`: protected
- Member variables follow a `name: type = value` syntax. The `type` and `= value` parts are optional.
- Composition is denoted with a diamond pointing at the component type declaration. In this case, it is the Point struct.
- Member variables are in the top section, and methods are in the bottom. In Dia, you can choose to hide either, as I did in the struct.
- Methods follow a different syntax: `method(arg1:type, arg2:type = value): ReturnType`
    - Parameters are optional, and are formatted like members
    - The return type is shown after the name and parameters
- As you will see below, classes that inherit another class are shown with an arrow pointing to the class they inherit

\subsection Example
The best way to show how inheritance works is to use it. For this reason, we will implement a class that contains shape properties, and then use inheritance to create classes that correspond to specific shapes. Many graphics libraries (often used to create games) have something similar to this. Note that this example will require basic trigonometry skills (applications of sine, cosine, and tangent).

\diafile ShapeClass.dia "Here is the UML inheritance diagram showing the relation between the Shape class and its decedents and components."

\note The default constructor for each class is implied.

\subsection cppclassinheritbase The Base Class: Shape
Here is the declaration and implementation of the `Shape` class.

###FILE: Shape.hh
~~~

~~~

\note `width` and `height` are protected because other classes may need access to them.

###FILE: Shape.cc
~~~

~~~

\subsection cppclassinheritchild1 Child Class: Rectangle
Here is the declaration and implementation of a very simple child class, `Rectangle`. The only additional methods it supplies are `area()` and `perimeter()`.

###FILE: Rectangle.hh
~~~

~~~

\note The encapsulation level before the name of the base class is important. It is the highest level that a member from `Shape` can be in a `Rectangle` object. In other words, if `public Shape` were changed to `private Shape`, all of the members that were previously public and protected would be private in the child class. Generally speaking, this is not what you want, and if you want to restrict the access to inherited members, composition is typically the way to go. This does not reduce the protection of any members - inheriting a class as public means that previously public members are public, protected members are protected, and private members are private.

###FILE: Rectangle.cc
~~~

~~~

For demonstration purposes, here is a simple test file.
~~~
#include <iostream>
#include "Rectangle.hh"
using namespace std;

int main() {
    Rectangle r;
    //The following line demonstrates how inheritance works:
    //getLocation is a method in Shape, but it is being called from a Rectangle object.
    cout << r.getLocation().x << ' ' << r.getLocation().y << '\n';
    r.setWidth(3);
    r.setHeight(2);
    //Call a method that only exists in Rectangle
    cout << r.area();
}
~~~

\subsection cppclassinheritfn Inheritance & Functions
Inheritance also provides a benefit when you are passing a class into a function. You can pass child classes into a function meant for the base class. In other words, you can pass a `Rectangle` into a function requiring a `Shape` argument. This makes since, a Rectangle will have no less than a Shape (assuming that it inherited Shape as public).

~~~
#include <iostream>
#include "Rectangle.hh"
using namespace std;

void printShape(Shape s) {
    cout << "Angle: " << s.getRotation() << " Layer: " << s.getLayer() << '\n'
         << "Location: " << s.getLocation().x << ' ' << s.getLocation().y << '\n'
         << "Width: " << s.getWidth() << " Height:" << s.getHeight() << '\n';
}

int main() {
    Rectangle r;
    printShape(r);
}
~~~

The above code works perfectly. Note that `r` is a `Rectangle` and the function's parameter type is a `Shape`. This would cause a compiler error if you set the encapsulation level when `Rectangle` inherited `Shape` were something other than `public`.

\note There is a more efficient way to write this function. See \ref cppclassfnconst "const functions".
*/
